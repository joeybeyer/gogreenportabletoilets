import fs from 'node:fs';
import path from 'node:path';
import { execSync } from 'node:child_process';

const BACKUP_DIR = 'backups';
const TIMESTAMP = new Date().toISOString().replace(/[:.]/g, '-').split('T')[0];
const BACKUP_NAME = `gogreen-backup-${TIMESTAMP}`;
const BACKUP_PATH = path.join(BACKUP_DIR, BACKUP_NAME);

// Ensure backup directory exists
fs.mkdirSync(BACKUP_DIR, { recursive: true });
fs.mkdirSync(BACKUP_PATH, { recursive: true });

console.log('ðŸ—‚ï¸ Creating comprehensive backup...');

// Files and directories to backup
const backupItems = [
  'src/',
  'public/',
  'scripts/',
  'docs/',
  '.github/',
  'package.json',
  'package-lock.json',
  'tsconfig.json',
  'tsconfig.app.json',
  'tsconfig.node.json',
  'vite.config.ts',
  'tailwind.config.js',
  'postcss.config.js',
  'eslint.config.js',
  'index.html',
  'README.md',
  'CONTRIBUTING.md',
  'netlify.toml',
  '.gitignore'
];

// Copy function that preserves directory structure
const copyRecursive = (src, dest) => {
  const stat = fs.statSync(src);
  
  if (stat.isDirectory()) {
    fs.mkdirSync(dest, { recursive: true });
    const items = fs.readdirSync(src);
    
    for (const item of items) {
      copyRecursive(path.join(src, item), path.join(dest, item));
    }
  } else {
    fs.copyFileSync(src, dest);
  }
};

// Create backup
let totalFiles = 0;
let totalSize = 0;

for (const item of backupItems) {
  if (fs.existsSync(item)) {
    console.log(`ðŸ“ Backing up: ${item}`);
    const destPath = path.join(BACKUP_PATH, item);
    
    try {
      copyRecursive(item, destPath);
      
      // Count files and calculate size
      const stat = fs.statSync(item);
      if (stat.isFile()) {
        totalFiles++;
        totalSize += stat.size;
      } else {
        // Count files in directory
        const countFiles = (dir) => {
          let count = 0;
          let size = 0;
          const items = fs.readdirSync(dir);
          
          for (const subItem of items) {
            const fullPath = path.join(dir, subItem);
            const subStat = fs.statSync(fullPath);
            
            if (subStat.isFile()) {
              count++;
              size += subStat.size;
            } else if (subStat.isDirectory()) {
              const subResult = countFiles(fullPath);
              count += subResult.count;
              size += subResult.size;
            }
          }
          
          return { count, size };
        };
        
        const result = countFiles(item);
        totalFiles += result.count;
        totalSize += result.size;
      }
      
    } catch (error) {
      console.warn(`âš ï¸ Could not backup ${item}:`, error.message);
    }
  } else {
    console.warn(`âš ï¸ Item not found: ${item}`);
  }
}

// Create backup manifest
const manifest = {
  backupName: BACKUP_NAME,
  timestamp: new Date().toISOString(),
  totalFiles,
  totalSize,
  sizeFormatted: `${(totalSize / 1024 / 1024).toFixed(2)} MB`,
  items: backupItems.filter(item => fs.existsSync(item)),
  gitCommit: (() => {
    try {
      return execSync('git rev-parse HEAD', { encoding: 'utf8' }).trim();
    } catch {
      return 'No git repository';
    }
  })(),
  nodeVersion: process.version,
  platform: process.platform
};

fs.writeFileSync(
  path.join(BACKUP_PATH, 'backup-manifest.json'),
  JSON.stringify(manifest, null, 2)
);

// Create README for backup
const backupReadme = `# GoGreen Portable Toilets - Backup

**Backup Created:** ${manifest.timestamp}
**Total Files:** ${manifest.totalFiles}
**Total Size:** ${manifest.sizeFormatted}
**Git Commit:** ${manifest.gitCommit}

## Contents

This backup contains:
- Complete source code
- All images and assets
- Configuration files
- Documentation
- GitHub workflows
- Build scripts

## Restoration Instructions

1. Extract this backup to a new directory
2. Install dependencies: \`npm install\`
3. Start development: \`npm run dev\`
4. Build for production: \`npm run build:site\`

## Backup Manifest

See \`backup-manifest.json\` for detailed backup information.

---
Generated by GoGreen backup system
`;

fs.writeFileSync(path.join(BACKUP_PATH, 'README.md'), backupReadme);

// Create ZIP archive if possible
try {
  console.log('ðŸ“¦ Creating ZIP archive...');
  execSync(`cd ${BACKUP_DIR} && zip -r ${BACKUP_NAME}.zip ${BACKUP_NAME}/`, { stdio: 'inherit' });
  console.log(`âœ… ZIP archive created: ${BACKUP_DIR}/${BACKUP_NAME}.zip`);
} catch (error) {
  console.warn('âš ï¸ Could not create ZIP archive:', error.message);
  console.log('ðŸ’¡ You can manually zip the backup folder if needed');
}

console.log('\nðŸŽ‰ Backup completed successfully!');
console.log(`ðŸ“ Backup location: ${BACKUP_PATH}`);
console.log(`ðŸ“Š Files backed up: ${totalFiles}`);
console.log(`ðŸ’¾ Total size: ${manifest.sizeFormatted}`);
console.log('\nðŸ“‹ Backup includes:');
manifest.items.forEach(item => console.log(`   âœ“ ${item}`));